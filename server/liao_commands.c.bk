#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>  
#include <sys/epoll.h>  
#include <sys/sendfile.h>  
#include <sys/wait.h>  
#include <sys/stat.h>  
#include <netinet/in.h>  
#include <netinet/tcp.h>  
#include <arpa/inet.h>  
#include <strings.h>  
#include "mysql.h"
#include "liao_log.h"
#include "liao_utils.h"
#include "liao_server.h"
#include "base64.h"

#include "confparser.h"
#include "dictionary.h"

extern char max_works[512];
extern struct clients *client_st;
extern dictionary *online_d;
extern struct confg_st config_st;


void commands(struct clients *client_t)
{
	char rspsoneBuf[512] = {0};
	struct data_st *recv_pdt = client_t->recv_data;
	if ((recv_pdt->data_len > 0) && (recv_pdt->data != NULL)) {
		
		// HELO: 用于表示客户端信息 helo uid:0000001 ios_token:xxxxxxxxxxxxxx fid:0000220
		if ( strncasecmp(recv_pdt->data, "HELO ", 5) == 0 ) {
			char *pbuf = recv_pdt->data + 5;
			char myuid[128] = {0};
			int ret = helo_cmd(client_t, pbuf, strlen(pbuf), myuid, sizeof(myuid));
			if (ret == 0) {
				// 检查是否有离线消息
				int offline_msg_num = has_offline_msg(myuid);
				snprintf(rspsoneBuf, sizeof(rspsoneBuf), "%s OK %d%s", TAG_HELO, offline_msg_num, DATA_END);
			} else {
				snprintf(rspsoneBuf, sizeof(rspsoneBuf), "%s FAIL%s", TAG_HELO, DATA_END);
			}

			// init recv data
			reinit_data_without_free(recv_pdt);

			safe_write(client_t, rspsoneBuf, strlen(rspsoneBuf));

			return ;
		}

		// SENDADDFRDREQ: 发送请求加为好友信息
		if ( strncasecmp(recv_pdt->data, "SENDADDFRDREQ", 13) == 0 ) {
			char *pbuf = recv_pdt->data + 13;
			char mid[MAX_LINE] = {0};
			int mid_size = MAX_LINE;
			int ret = sendreq_addfriend(client_t, pbuf, strlen(pbuf), mid, mid_size);
			if (ret == 0) {
				snprintf(rspsoneBuf, sizeof(rspsoneBuf), "%s OK %s", TAG_SENDADDFRIENDREQ, DATA_END);
			} else {
				snprintf(rspsoneBuf, sizeof(rspsoneBuf), "%s FAIL %s", TAG_SENDADDFRIENDREQ, DATA_END);
			}

			// init recv data
			reinit_data_without_free(recv_pdt);

			safe_write(client_t, rspsoneBuf, strlen(rspsoneBuf));
			return;
		}
	
	}
}


// System Command
//
//
//
void status_cmd(int sockfd, char *pbuf, size_t pbuf_size)
{
	log_debug("pbuf:%s", pbuf);

	// 在线dump
	//printf("online list:\n");
	write(sockfd, "online list:\n", strlen("online list:\n"));
	
	write(sockfd, "\tsock_fd => ios_token:\n", strlen("\tsock_fd => ios_token:\n"));
	online_dump(online_d, sockfd);


	// client info
	char buf[10*1024] = {0};
	write(sockfd, "client list info:\n", strlen("client list info:\n"));
	int i = 0, online_num = 0;;
	for (i=0; i<(atoi(config_st.max_works) + 1); i++) {
		if (client_st[i].used == 1) {
			snprintf(buf, sizeof(buf), "\t[%d] used[%d] fd[%d] uid[%s] ios_token[%s]\n", i, client_st[i].used, client_st[i].fd, client_st[i].uid, client_st[i].ios_token);
			write(sockfd, buf, strlen(buf));
			memset(buf, 0, sizeof(buf));

			online_num++;
		}
	}

	snprintf(buf, sizeof(buf), "online:%d all:%d\n", online_num, atoi(config_st.max_works));
	write(sockfd, buf, strlen(buf));
}





// Client Command
//
//

// HELO: 用于表示客户端信息	helo fuid:0000001 fdevtoken:xxxxxxxxxxxxxx
int helo_cmd(struct clients *client_t, char *pbuf, size_t pbuf_size, char *myuid, size_t myuid_size)
{
	int sockfd = client_t->fd;
	log_debug("pbuf:[%s]", pbuf);

	// pbuf[uid:0000001 ios_token:xxxxxxxxxxxxxx]
	char fuid[MAX_LINE] = {0};
	char fios_token[MAX_LINE] = {0};

	char tok[MAX_LINE] = {0};
	char *ptok = tok;
	
	int n = pbuf_size;
	while ((*pbuf != '\0') && (n > 0)) {
		char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
		if (psed != NULL) {
			int m = (psed - pbuf);
			memcpy(ptok, pbuf, m);
			pbuf += (m + 1);
			n -= (m + 1);

		} else {
			ptok = pbuf;
			n -= strlen(pbuf);
		}
		
		log_debug("ptok:[%s]", ptok);
		if (strncasecmp(ptok, "fuid:", 5) == 0) {
			snprintf(fuid, sizeof(fuid), "%s", ptok+5);
			log_debug("from uid:[%s]", fuid);
		} else if (strncasecmp(ptok, "fios_token:", 11) == 0) {
			snprintf(fios_token, sizeof(fios_token), "%s", ptok+11);
			log_debug("from ios_token:[%s]", fios_token);
		}
		
		memset(ptok, 0, strlen(ptok));
	}
	log_debug("get sockfd[%d] from fuid[%s]", sockfd, fuid);
	log_debug("get sockfd[%d] from fios_token[%s]", sockfd, fios_token);

	if ( ( strlen(fuid) <= 0 ) || ( strlen(fios_token) <= 0 ) ) {
		log_error("get sockfd[%d] parameter error", sockfd);
		return 1;
	}
	

	snprintf(client_t->uid, sizeof(client_t->uid), "%s", fuid);
	snprintf(client_t->ios_token, sizeof(client_st->ios_token), "%s", fios_token);
	
	// 注册为在线	(uid => ios_token)
	int ret = dictionary_set(online_d, fuid, fios_token);
	if (ret != 0) {
		log_error("add to online failed uid[%s] sockfd[%d] ios_token[%s]", fuid, sockfd, fios_token);
	}
	log_debug("registon online succ uid[%s] ios_token[%s] sockfd[%d]", fuid, fios_token, sockfd);

	snprintf(myuid, myuid_size, "%s", fuid);

	return 0;
	
}


int get_offline_msg(int sockfd, char *pbuf, size_t pbuf_size)
{
	char fuid[MAX_LINE] = {0};	
	char *message = NULL;	
		
	char tok[MAX_LINE] = {0};
	char *ptok = tok;
	
	int n = pbuf_size;
	while ((*pbuf != '\0') && (n > 0)) {

		char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
        if (psed != NULL) {
            int m = (psed - pbuf);
            memcpy(ptok, pbuf, m); 
            pbuf += (m + 1); 
            n -= (m + 1); 

        } else {
            ptok = pbuf;
            n -= strlen(pbuf);
        }   
            
        log_debug("ptok:[%s]", ptok);	
		if (strncasecmp(ptok, "fuid:", 5) == 0) {
			snprintf(fuid, sizeof(fuid), "%s", ptok+5);
			break;
		}

		memset(ptok, 0, strlen(ptok));
	}
	log_debug("get sockfd[%d] fuid[%s]", sockfd, fuid);

	
	message = get_offline_msg_with_uid(fuid);
	if (message == NULL) {
		return 1;
	}

	int i = get_idx_with_uid(fuid);
	if ((i == -1) || (client_st[i].used != 1) || (client_st[i].fd != sockfd) ) {
		log_error("logic is error, i[%d] = get_idx_with_uid(%s), client_st[i].used:%d client_st[i].fd:%d", i, fuid, client_st[i].used, client_st[i].fd);

		goto FAIL;
	}

	if ( (i >= 0) && (n == 0) ) {
		struct data_st *send_pdt = client_st[i].send_data;
		int tfd = client_st[i].fd;

		int bufsize = strlen(message);	

		if (send_pdt->data == NULL) {
			send_pdt->data_size = bufsize + 1;
			send_pdt->data = (char *)calloc(1, bufsize + 1);
			if (send_pdt->data == NULL) {
                send_pdt->data_size = 0;

                log_error("calloc failed:%s size[%d]", strerror(errno), bufsize + 1);
				goto FAIL;
            }
            send_pdt->data_len = 0;

		} else {
			int is_remem_succ = 1;
			if (send_pdt->data_size < (bufsize + 1)) {
				size_t new_size = (send_pdt->data_size + (bufsize + 1)) * 3;
				int fail_times = 1;
				char *tmp = send_pdt->data;
				while ( (send_pdt->data = (char *)realloc(send_pdt->data, new_size)) == NULL ) {
					if (fail_times >= 4) {
						log_error("we can't realloc memory. ");

						send_pdt->data = tmp;
						is_remem_succ = 0;
						break;
					}

					log_error("realloc fail times[%d], retry it.", fail_times);
					sleep(1);
				}

				if (is_remem_succ == 1) {
					send_pdt->data_size = new_size;
				}
			}

			memset(send_pdt->data, 0, send_pdt->data_size);
		}

		n = snprintf(send_pdt->data, send_pdt->data_size, "%s", message);
		send_pdt->data_len = n;
		send_pdt->data_used = 0;

		if (message) {
			free(message);
			message = NULL;
		}

		epoll_event_mod(sockfd, EPOLLOUT);

		log_debug("add send message to fd[%d] msg len:%d", sockfd, send_pdt->data_len);

		return 0;
	}	


FAIL:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	return 1;

}

int sendreq_addfriend(struct clients *client_t, char *pbuf, size_t pbuf_size, char *mid, size_t mid_size)
{
	log_debug("pbuf:%s", pbuf);

	int sockfd = client_t->fd;
    char fuid[MAX_LINE] = {0};
    char fios_token[MAX_LINE] = {0};
    char fnick[MAX_LINE] = {0};
    char tuid[MAX_LINE] = {0};
    char tios_token[MAX_LINE] = {0};

	char *message = NULL;
    message = (char *)calloc(1, pbuf_size + 1); 
    if (message == NULL) {
        log_error("calloc failed:%s size:%d", strerror(errno), pbuf_size + 1); 
        goto TXT_FAIL;
    }   

    char tok[MAX_LINE] = {0};
    char *ptok = tok;
        
    int n = pbuf_size;
    while ((*pbuf != '\0') && (n > 0)) {
        char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
        if (psed != NULL) {
            int m = (psed - pbuf);
            memcpy(ptok, pbuf, m); 
            pbuf += (m + 1); 
            n -= (m + 1); 

        } else {
            ptok = pbuf;
            n -= strlen(pbuf);
        }   
    
        log_debug("ptok:[%s]", ptok);	
		if (strncasecmp(ptok, "mid:", 4) == 0) {
            snprintf(mid, mid_size, "%s", ptok+4);
        } else if (strncasecmp(ptok, "fuid:", 5) == 0) {
            snprintf(fuid, sizeof(fuid), "%s", ptok+5);
        } else if (strncasecmp(ptok, "fios_token:", 11) == 0) {
            snprintf(fios_token, sizeof(fios_token), "%s", ptok+11);
        } else if (strncasecmp(ptok, "fnick:", 6) == 0) {
            snprintf(fnick, sizeof(fnick), "%s", ptok+6);
        } else if (strncasecmp(ptok, "tuid:", 5) == 0) {
            snprintf(tuid, sizeof(tuid), "%s", ptok+5);
        } else if (strncasecmp(ptok, "tios_token:", 11) == 0) {
            snprintf(tios_token, sizeof(tios_token), "%s", ptok+11);

            break;
        }

        memset(ptok, 0, strlen(ptok));
    }
    log_debug("get sockfd[%d] mid[%s]", sockfd, mid);
    log_debug("get sockfd[%d] fuid[%s]", sockfd, fuid);
    log_debug("get sockfd[%d] fios_token[%s]", sockfd, fios_token);
    log_debug("get sockfd[%d] fnick[%s]", sockfd, fnick);
    log_debug("get sockfd[%d] tid[%s]", sockfd, tuid);
    log_debug("get sockfd[%d] tios_token[%s]", sockfd, tios_token);


	// 生成转发消息
	int bufsize = 13 + 6 + strlen(fuid) + 10 + 7 + strlen(fnick) + 7 + 10 + strlen(message) + 10;
	char *precv_data = (char *)calloc(1, bufsize + 1);
	if (precv_data == NULL) {
		log_error("calloc failed for precv_data size:%d", (bufsize + 1));
		//return 1;
		goto TXT_FAIL;
	}
	n = snprintf(precv_data, (bufsize + 1), "%s fuid:%s fnick:%s%s", TAG_RECVADDFRIENDREQ, fuid, fnick, DATA_END);
	log_debug("recv_data len:%d:%s", n, precv_data);

	// 写消息到队列
	char queue_file[MAX_LINE] = {0};
	n = write_content_to_file_with_uid(tuid, precv_data, n, queue_file, sizeof(queue_file));
	if (n != 0) {
		log_error("write_content_to_file_with_uid fail");
		goto TXT_FAIL;
	}

	// 写消息索引到数据库

	MYSQL mysql, *mysql_sock;
    MYSQL_RES* res = NULL;
    char sql[5 * MAX_LINE] = {0};	
	
	log_debug("quar_mysql:%s mysql_user:%s mysql_pass:%s mysql_db:%s mysql_port:%d", config_st.mysql_host, config_st.mysql_user, config_st.mysql_passwd, config_st.mysql_db, config_st.mysql_port);
	mysql_init(&mysql);
	if (!(mysql_sock = mysql_real_connect(&mysql, config_st.mysql_host, config_st.mysql_user, config_st.mysql_passwd, config_st.mysql_db, config_st.mysql_port, NULL, 0))) {
		log_error("connect mysql fail");
		goto TXT_FAIL;
	}

	// addslash
	char mysql_fnick[MAX_LINE] = {0};
	char mysql_fios_token[MAX_LINE] = {0};
	char mysql_tios_token[MAX_LINE] = {0};
	char mysql_queue_file[MAX_LINE] = {0};

	mysql_real_escape_string(mysql_sock, mysql_fnick, fnick, strlen(fnick));
	mysql_real_escape_string(mysql_sock, mysql_fios_token, fios_token, strlen(fios_token));
	mysql_real_escape_string(mysql_sock, mysql_tios_token, tios_token, strlen(tios_token));
	mysql_real_escape_string(mysql_sock, mysql_queue_file, queue_file, strlen(queue_file));

	snprintf(sql, sizeof(sql), "insert into liao_queue (fuid, fnick, fios_token, tuid, tios_token, queue_file, expire) values (%d, '%s', '%s', %d, '%s', '%s', 0);", 
		atoi(fuid), mysql_fnick, mysql_fios_token, atoi(tuid), mysql_tios_token, mysql_queue_file);	

	if (mysql_query(mysql_sock, sql)) {
		log_error("insert mysql liao_queue fail:%s", mysql_error(mysql_sock));
		mysql_close(mysql_sock);

		goto TXT_FAIL;
	}
	
	mysql_close(mysql_sock);


	// 发送通知
	log_debug("tuid:%s is offline, use APNS send message", tuid);

	send_apn_cmd(tios_token, fuid, fnick);

	goto TXT_SUCC;
	
	

TXT_FAIL:
	if (strlen(queue_file) > 0) {
		unlink(queue_file);
	}

	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 1;

TXT_SUCC:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 0;
}



// sendtxt mid:xxxxx fuid:0000001 fios_token:xxxxxxxxxxxxxx fnick:xxxxx tuid:0000220 tios_token:ccccccccccccccc message:32:abcabcabc
int sendtxt_cmd(int sockfd, char *pbuf, size_t pbuf_size, char *mid, size_t mid_size, int client_idx)
{
	log_debug("pbuf:%s", pbuf);
	
	// pbuf[mid:xxxxx fuid:0000001 fios_token:xxxxxxxxxxxxxx fnick:xxxxxx tuid:0000220 tios_token:ccccccccccccccc message:32:abcabcabc]
	int ci  = client_idx;
	char fuid[MAX_LINE] = {0};
	char fios_token[MAX_LINE] = {0};
	char fnick[MAX_LINE] = {0};
	char tuid[MAX_LINE] = {0};
	char tios_token[MAX_LINE] = {0};
	//char message[MAX_LINE] = {0};
	char *message = NULL;
	message = (char *)calloc(1, pbuf_size + 1);
	if (message == NULL) {
		log_error("calloc failed:%s size:%d", strerror(errno), pbuf_size + 1);
		goto TXT_FAIL;
	}

	char tok[MAX_LINE] = {0};
	char *ptok = tok;
	
	int n = pbuf_size;
	while ((*pbuf != '\0') && (n > 0)) {
		char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
		if (psed != NULL) {
			int m = (psed - pbuf);
			memcpy(ptok, pbuf, m);
			pbuf += (m + 1);
			n -= (m + 1);

		} else {
			ptok = pbuf;
			n -= strlen(pbuf);
		}
		
		log_debug("ptok:[%s]", ptok);
		if (strncasecmp(ptok, "mid:", 4) == 0) {
			snprintf(mid, mid_size, "%s", ptok+4);
		} else if (strncasecmp(ptok, "fuid:", 5) == 0) {
			snprintf(fuid, sizeof(fuid), "%s", ptok+5);
		} else if (strncasecmp(ptok, "fios_token:", 11) == 0) {
			snprintf(fios_token, sizeof(fios_token), "%s", ptok+11);
		} else if (strncasecmp(ptok, "fnick:", 6) == 0) {
			snprintf(fnick, sizeof(fnick), "%s", ptok+6);
		} else if (strncasecmp(ptok, "tuid:", 5) == 0) {
			snprintf(tuid, sizeof(tuid), "%s", ptok+5);
		} else if (strncasecmp(ptok, "tios_token:", 11) == 0) {
			snprintf(tios_token, sizeof(tios_token), "%s", ptok+11);
		} else if (strncasecmp(ptok, "message:", 8) == 0) {
			snprintf(message, pbuf_size, "%s", ptok + 8);

			break;
		}
		
		memset(ptok, 0, strlen(ptok));
	}
	log_debug("get sockfd[%d] mid[%s]", sockfd, mid);
	log_debug("get sockfd[%d] fuid[%s]", sockfd, fuid);
	log_debug("get sockfd[%d] fios_token[%s]", sockfd, fios_token);
	log_debug("get sockfd[%d] fnick[%s]", sockfd, fnick);
	log_debug("get sockfd[%d] tid[%s]", sockfd, tuid);
	log_debug("get sockfd[%d] tios_token[%s]", sockfd, tios_token);
	log_debug("get sockfd[%d] message[%s]", sockfd, message);


	// 生成转发消息
	int bufsize = 8 + 6 + strlen(fuid) + 10 + 7 + strlen(fnick) + 7 + 10 + strlen(message) + 10;
	char *precv_data = (char *)calloc(1, bufsize + 1);
	if (precv_data == NULL) {
		log_error("calloc failed for precv_data size:%d", (bufsize + 1));
		//return 1;
		goto TXT_FAIL;
	}
	n = snprintf(precv_data, (bufsize + 1), "%s fuid:%s fnick:%s message:%d:%s%s", TAG_RECVTXT, fuid, fnick, strlen(message), message, DATA_END);
	log_debug("recv_data len:%d", n);

	
	// 检查收件人是否在线
	char *pf_fd = dictionary_get(online_d, tuid, NULL);
	if (pf_fd == NULL) {
		// 写消息到队列
		//n = write_content_to_file_with_uid(tuid, precv_data, n);	
		if (n != 0) {
			log_error("write_content_to_file_with_uid, tuid:%s n:%d fail", tuid, n);
			//return 1;	
			goto TXT_FAIL;
		}

		// 用户不在线, 使用 APNS
		log_debug("tuid:%s is offline, use APNS send message", tuid);

		send_apn_cmd(tios_token, fuid, fnick);

		//return 0;
		goto TXT_SUCC;
		
	} else {
		// 查询fd
		log_debug("tuid:%s is online, use socket send message", tuid);

		int i = get_idx_with_uid(tuid);
		if ((i == -1) || (client_st[i].used != 1)) {
			log_error("logic is error, i[%d] = get_idx_with_uid(%s), client_st[i].used=%d", i, tuid, client_st[i].used);
			//return 1;
			goto TXT_FAIL;
		}

		int fsockfd = client_st[i].fd;
		
		// 直接发送信息
		char buf[10*1024] = {0};

		if (i >= 0 ) {
			//int bufsize = 8 + 6 + strlen(fuid) + 10 + 7 + strlen(fnick) + 7 + 10 + strlen(message) + 10;

			struct data_st *send_pdt = client_st[i].send_data;
			int tfd = client_st[i].fd;
			
			if (send_pdt->data == NULL) {
				send_pdt->data_size = bufsize + 1;
				send_pdt->data = (char *)calloc(1, bufsize + 1);
				if (send_pdt->data == NULL) {
					send_pdt->data_size = 0;

					log_error("calloc failed:%s size[%d]", strerror(errno), bufsize + 1);
					//return 1;
					goto TXT_FAIL;
				}
				send_pdt->data_len = 0;

			} else {

				int is_remem_succ = 1;
				if (send_pdt->data_size < (bufsize + 1)) {
					size_t new_size = (send_pdt->data_size + (bufsize + 1)) * 3;
					int fail_times = 1;
					char *tmp = send_pdt->data;
					while ( (send_pdt->data = (char *)realloc(send_pdt->data, new_size)) == NULL ) {	
						if (fail_times >= 4) {
							log_error("we can't realloc memory. ");
							
							send_pdt->data = tmp;
							is_remem_succ = 0;
							break;
						}
						
						log_error("realloc fail times[%d], retry it.", fail_times);
						sleep(1);
					}

					if (is_remem_succ == 1) {
						send_pdt->data_size = new_size;
					}
				}

				memset(send_pdt->data, 0, send_pdt->data_size);

			}

			//int n = snprintf(send_pdt->data, send_pdt->data_size, "%s fuid:%s fnick:%s message:%d:%s%s", TAG_RECVTXT, fuid, fnick, strlen(message), message, DATA_END);
			n = snprintf(send_pdt->data, send_pdt->data_size, "%s", precv_data);
			send_pdt->data_len = n;
			send_pdt->data_used = 0;


			if (precv_data) {
				free(precv_data);
				precv_data = NULL;
			}

			epoll_event_mod(tfd, EPOLLOUT);
		
			log_debug("add send message to fd[%d] msg len:%d", fsockfd, send_pdt->data_len);

			//return 0;
			goto TXT_SUCC;
		}
		
		//return 1;
		goto TXT_FAIL;
	}


TXT_FAIL:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 1;

TXT_SUCC:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 0;
} 

// sendimg mid:xxxxx fuid:0000001 fios_token:xxxxxxxxxxxxxx fnick:xxxx tuid:0000220 tios_token:ccccccccccccccc file_name:abcd.JPG message:23:abcabcabc
int sendimg_cmd(int sockfd, char *pbuf, size_t pbuf_size, char *mid, size_t mid_size, int client_idx, char *img_full_host, size_t img_full_host_size, char *iname, size_t iname_size)
{
	log_debug("pbuf:%s", pbuf);
	
	// pbuf[mid:xxxxx fuid:0000001 fios_token:xxxxxxxxxxxxxx fnick:xxxx tuid:0000220 tios_token:ccccccccccccccc file_name:abcd.JPG message:23:abcabcabc]
	int ci = client_idx;
	char fuid[MAX_LINE] = {0};
	char fios_token[MAX_LINE] = {0};
	char fnick[MAX_LINE] = {0};
	char tuid[MAX_LINE] = {0};
	char tios_token[MAX_LINE] = {0};
	char file_name[MAX_LINE] = {0};
	char *message = NULL;
	message = (char *)calloc(1, pbuf_size + 1);
	if (message == NULL) {
		log_error("calloc failed:%s size:%d", strerror(errno), pbuf_size + 1);
		goto IMG_FAIL;
	}

	int b64_message_size =  pbuf_size + 1;
	char *b64_message = NULL;
    b64_message = (char *)calloc(1, pbuf_size + 1); 
    if (b64_message == NULL) {
        log_error("calloc failed:%s size:%d", strerror(errno), b64_message_size); 
        //return 1;
        goto IMG_FAIL;
    }
	
	char tok[MAX_LINE] = {0};
	char *ptok = tok;
	
	int n = pbuf_size;
	while ((*pbuf != '\0') && (n > 0)) {
		char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
		if (psed != NULL) {
			int m = (psed - pbuf);
			memcpy(ptok, pbuf, m);
			pbuf += (m + 1);
			n -= (m + 1);

		} else {
			ptok = pbuf;
			n -= strlen(pbuf);
		}
		
		log_debug("ptok:[%s]", ptok);
		if (strncasecmp(ptok, "mid:", 4) == 0) {
			snprintf(mid, mid_size, "%s", ptok+4);
		} else if (strncasecmp(ptok, "fuid:", 5) == 0) {
			snprintf(fuid, sizeof(fuid), "%s", ptok+5);
		} else if (strncasecmp(ptok, "fios_token:", 11) == 0) {
			snprintf(fios_token, sizeof(fios_token), "%s", ptok+11);
		} else if (strncasecmp(ptok, "fnick:", 6) == 0) {
			snprintf(fnick, sizeof(fnick), "%s", ptok+6);
		} else if (strncasecmp(ptok, "tuid:", 5) == 0) {
			snprintf(tuid, sizeof(tuid), "%s", ptok+5);
		} else if (strncasecmp(ptok, "tios_token:", 11) == 0) {
			snprintf(tios_token, sizeof(tios_token), "%s", ptok+11);
		} else if (strncasecmp(ptok, "file_name:", 10) == 0) {
			snprintf(file_name, sizeof(file_name), "%s", ptok+10);
		} else if (strncasecmp(ptok, "message:", 8) == 0) {
			snprintf(message, pbuf_size, "%s", ptok + 8);

			break;
		}
		
		memset(ptok, 0, strlen(ptok));
	}
	log_debug("get sockfd[%d] mid[%s]", sockfd, mid);
	log_debug("get sockfd[%d] fuid[%s]", sockfd, fuid);
	log_debug("get sockfd[%d] fios_token[%s]", sockfd, fios_token);
	log_debug("get sockfd[%d] fnick[%s]", sockfd, fnick);
	log_debug("get sockfd[%d] tid[%s]", sockfd, tuid);
	log_debug("get sockfd[%d] tios_token[%s]", sockfd, tios_token);
	log_debug("get sockfd[%d] file_name[%s]", sockfd, file_name);
	log_debug("get sockfd[%d] message[%s]", sockfd, message);


	// 做base64解码
	int b64_n = base64_decode(message, b64_message, b64_message_size);
	if (b64_n <= 0) {
		log_error("base64_decode fail");
		goto IMG_FAIL;
	}
	log_debug("base64_decode succ[%d]", b64_n);


	// 写文件到本地磁盘
	char fn_name[MAX_LINE] = {0};
	char img_full_path[MAX_LINE] = {0};
	FILE *fn_fp = open_img_with_name(file_name, tuid, fn_name, sizeof(fn_name), img_full_path, sizeof(img_full_path), img_full_host, img_full_host_size);
	if (fn_fp == NULL) {
        log_error("mail_pid_open fail:%s", strerror(errno));  

		goto IMG_FAIL;
    }

	struct stat pidst;
    if (fstat(fileno(fn_fp), &pidst) == -1) {
        if(*fn_name) {
            unlink(fn_name);
        }   

        if (fn_fp) {
            fclose(fn_fp);
			fn_fp = NULL;
        }   

        log_error("fstat[%s] fail:%s", fn_name, strerror(errno));

		goto IMG_FAIL;
    }

    if (fwrite(b64_message, b64_n, 1, fn_fp) != 1) {
		log_error("fwrite fail:%s", strerror(errno));

		if(*fn_name) {
            unlink(fn_name);
        }

        if (fn_fp) {
            fclose(fn_fp);
			fn_fp = NULL;
        }
		
		goto IMG_FAIL;

	}

	fclose(fn_fp);
	fn_fp = NULL;

	// 生成缩略图
	char img_thumb_full_name[MAX_LINE] = {0};
	snprintf(img_thumb_full_name, sizeof(img_thumb_full_name), "%s/s_%s", img_full_path, fn_name);
	char img_full_name[MAX_LINE] = {0};
	snprintf(img_full_name, sizeof(img_full_name), "%s/%s", img_full_path, fn_name);
	int ret = image_resize_without_scale(img_full_name, img_thumb_full_name, 95);
	if (ret != 0) {
		log_error("create thumb fail:[%s] -> [%s]", img_full_name, img_thumb_full_name);
	} else {
		snprintf(iname, iname_size, "s_%s", fn_name);
	}

	
	// 生成转发消息
	int bufsize = 8 + 6 + strlen(fuid) + 10 + 7 + strlen(fnick) + 7 + 11 + strlen(fn_name) + 13 + 5 + strlen(img_full_host) + 10;
	char *precv_data = (char *)calloc(1, bufsize + 1);
	if (precv_data == NULL) {
		log_error("calloc fail for precv_data size:%d", (bufsize + 1));
		goto IMG_FAIL;
	}
	n = snprintf(precv_data, (bufsize + 1), "%s fuid:%s fnick:%s file_name:s_%s message:%d:%s%s", TAG_RECVIMG, fuid, fnick, fn_name, strlen(img_full_host), img_full_host, DATA_END);
	log_debug("recv_data len:%d", n);


	// 检查收件人是否在线
	char *pf_fd = dictionary_get(online_d, tuid, NULL);
	if (pf_fd == NULL) {

		// 写消息到队列
		//n = write_content_to_file_with_uid(tuid, precv_data, n);	
		if (n != 0) {
			log_error("write_content_to_file_with_uid, tuid:%s n:%d fail", tuid, n);
			//return 1;	
			goto IMG_FAIL;
		}

		// 用户不在线, 使用 APNS
		log_debug("tuid:%s is offline, use APNS send message", tuid);

		send_apn_cmd(tios_token, fuid, fnick);

		//return 0;
		goto IMG_SUCC;
		
	} else {
		// 查询fd
		log_debug("tuid:%s is online, use socket send message", tuid);

		int i = get_idx_with_uid(tuid);
		if ((i == -1) || (client_st[i].used != 1)) {
			log_error("logic is error, i[%d] = get_idx_with_uid(%s), client_st[i].used=%d", i, tuid, client_st[i].used);
			return 1;
		}

		int fsockfd = client_st[i].fd;
		
		// 直接发送信息
		if (i >= 0) {

			//int bufsize = 8 + 6 + strlen(fuid) + 10 + 7 + strlen(fnick) + 7 + 11 + strlen(file_name) + 10 + 5 + strlen(IMG_HOST) + strlen(fn_name) + 10;

			struct data_st *send_pdt = client_st[i].send_data;
			int tfd = client_st[i].fd;

			if (send_pdt->data == NULL) {
				send_pdt->data_size = bufsize + 1;
				send_pdt->data = (char *)calloc(1, bufsize + 1);
				if (send_pdt->data == NULL) {
					send_pdt->data_size = 0;

					log_error("calloc failed:%s size[%d]", strerror(errno), bufsize + 1);
					//return 1;
					goto IMG_FAIL;
				}
				send_pdt->data_len = 0;

			} else {

				int is_remem_succ = 1;
				if (send_pdt->data_size < (bufsize + 1)) {
					size_t new_size = (send_pdt->data_size + (bufsize + 1)) * 3;
					int fail_times = 1;
					char *tmp = send_pdt->data;
					while ( (send_pdt->data = (char *)realloc(send_pdt->data, new_size)) == NULL ) {	
						if (fail_times >= 4) {
							log_error("we can't realloc memory. ");
							
							send_pdt->data = tmp;
							is_remem_succ = 0;
							break;
						}
						
						log_error("realloc fail times[%d], retry it.", fail_times);
						sleep(1);
					}

					if (is_remem_succ == 1) {
						send_pdt->data_size = new_size;
					}
				}

				memset(send_pdt->data, 0, send_pdt->data_size);
			}

			n = snprintf(send_pdt->data, send_pdt->data_size, "%s", precv_data);
			//int n = snprintf(send_pdt->data, send_pdt->data_size, "%s fuid:%s fnick:%s file_name:%s message:%d:%s%s", TAG_RECVIMG, fuid, fnick, file_name, strlen(message), message, DATA_END);
			//int n = snprintf(send_pdt->data, send_pdt->data_size, "%s fuid:%s fnick:%s file_name:%s fn_name:%d:%s/%s%s", TAG_RECVIMG, fuid, fnick, file_name, strlen(message), IMG_HOST, fn_name, DATA_END);
			send_pdt->data_len = n;
			send_pdt->data_used = 0;

			if (precv_data) {
				free(precv_data);
				precv_data = NULL;
			}

			log_debug("add send message to fd[%d] msg len:%d", fsockfd, send_pdt->data_len);

			epoll_event_mod(tfd, EPOLLOUT);


			//return 0;	
			goto IMG_SUCC;
		}

		//return 1;
		goto IMG_FAIL;
	}


IMG_FAIL:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (b64_message != NULL) {
		free(b64_message);
		b64_message = NULL;
	}
	b64_message_size = 0;

	if (fn_fp != NULL) {
		fclose(fn_fp);
		fn_fp = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 1;

IMG_SUCC:
	if (message != NULL) {
		free(message);
		message = NULL;
	}

	if (b64_message != NULL) {
		free(b64_message);
		b64_message = NULL;
	}
	b64_message_size = 0;

	if (fn_fp != NULL) {
		fclose(fn_fp);
		fn_fp = NULL;
	}

	if (precv_data != NULL) {
		free(precv_data);
		precv_data = NULL;
	}

	return 0;
} 

// quit fuid:0000001 
int quit_cmd(int sockfd, char *pbuf, size_t pbuf_size)
{
	log_debug("pbuf:%s", pbuf);
	
	// pbuf[uid:0000001]
	char fuid[MAX_LINE] = {0};
	
	char tok[MAX_LINE] = {0};
	char *ptok = tok;
	
	int n = pbuf_size;
	while ((*pbuf != '\0') && (n > 0)) {
		char *psed = (char *)memchr(pbuf, ' ', strlen(pbuf));
		if (psed != NULL) {
			int m = (psed - pbuf);
			memcpy(ptok, pbuf, m);
			pbuf += (m + 1);
			n -= (m + 1);

		} else {
			ptok = pbuf;
			n -= strlen(pbuf);
		}
		
		log_debug("ptok:[%s]", ptok);
		if (strncasecmp(ptok, "fuid:", 5) == 0) {
			snprintf(fuid, sizeof(fuid), "%s", ptok+5);
		}

		memset(ptok, 0, strlen(ptok));
	}
	log_debug("get sockfd[%d] fuid[%s]", sockfd, fuid);
	
	// 设置离线
	// 查询fd
	int i = get_idx_with_uid(fuid);
	if (i == -1) {
		log_error("get index failed: i[%d] = get_idx_with_uid(%s)", i, fuid);
		return 1;
	}

	client_st[i].used = 0;
	client_st[i].fd = 0;
	memset(client_st[i].uid, '0', strlen(client_st[i].uid));
	memset(client_st[i].ios_token, '0', strlen(client_st[i].ios_token));
	
	// 注册为离线	(uid => ios_token)
	dictionary_unset(online_d, fuid);
	log_error("offline failed fuid[%s] sockfd[%d]", fuid, sockfd);
	
	
	return 0;
}
